<!DOCTYPE html>
<html>
<head>
	<style>
	body {
		margin 0;
		overflow: hidden;
	}
	</style>
	<meta charset="utf-8">
	<title></title>
</head>
<body>
<script type = "module">
import * as THREE from "https://web.cs.manchester.ac.uk/three/three.js-master/build/three.module.js";
import { OrbitControls } from  "https://web.cs.manchester.ac.uk/three/three.js-master/examples/jsm/controls/OrbitControls.js";

const particleGeometry = new THREE.BufferGeometry();
particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0], 3));

// const material = new THREE.PointsMaterial( { size: 1, sizeAttenuation: false } );
const particleMaterial = new THREE.PointsMaterial( { color: 0xAAAAAA } );

var constants = {
	dt: 1/60,
	g: -9.81,
}
// constants.g *= constants.dt;


function addVectors(v1, v2) {
	return {x: v1.x+v2.x, y: v1.y+v2.y, z: v1.z+v2.z};
}

function vector(x, y, z) {
	return {x: x, y: y, z: z};
}

function vectorFromV3(v) {
	return {x: v.x, y: v.y, z: v.z};
}

function vectorToArray(v) {
	return [v.x, v.y, v.z];
}

class Particle {
	constructor(position, velocity, secondsToLive, level) {
		// internal properties
		this.velocity = velocity;
		this.timeToLive = secondsToLive;
		this.totalTimeToLive = secondsToLive;
		this.level = level;

		this.isAlive = true;

		// scene object
		this.particle = new THREE.Points(particleGeometry, particleMaterial);
		this.particle.position.x = position.x;
		this.particle.position.y = position.y;
		this.particle.position.z = position.z;

		scene.add(this.particle);
	}

	updateVelocity() {
		this.velocity.y += constants.g * constants.dt;
	}

	updatePosition() {	
		this.particle.position.x += this.velocity.x * constants.dt;
		this.particle.position.y += this.velocity.y * constants.dt;
		this.particle.position.z += this.velocity.z * constants.dt;
	}

	updateLifetime() {
		this.timeToLive -= constants.dt;

		if (this.particle.position.y < 0) {
			this.delete();
			return;
		}

		if ((this.level == 2 && Math.abs(this.velocity.y) < 0.1) || this.timeToLive <= 0) {
			if (this.level > 0) {
				console.log("Exploding from", this.particle.position, "beacuse ", this.timeToLive <= 0 ? "this.timeToLive <= 0" : this.velocity);
				this.explode(7*this.level, 50*this.level);
			}
			this.delete();
		}
	}

	update() {
		this.updateVelocity();
		this.updatePosition();
		this.updateLifetime();
	}

	delete() {
		this.isAlive = false;
		scene.remove(this.particle);
	}

	explode(radius, particlesNumber) {
		var v;
		var pos = vectorFromV3(this.particle.position);

		for (var i = 0; i < particlesNumber; i++) {
			v = addVectors(this.randomPointOnASphrere(radius), this.velocity);
			particleManager.addParticle(new Particle(pos, v, this.totalTimeToLive*0.6, this.level-1));
		}
		
	}

	// from https://karthikkaranth.me/blog/generating-random-points-in-a-sphere/
	randomPointOnASphrere(radius) {
	    var theta = Math.random() * 2.0*Math.PI;
	    var phi = Math.random() * Math.PI;
	    var sinTheta = Math.sin(theta); var cosTheta = Math.cos(theta);
	    var sinPhi = Math.sin(phi); var cosPhi = Math.cos(phi);
	    var x = radius * sinPhi * cosTheta;
	    var y = radius * sinPhi * sinTheta;
	    var z = radius * cosPhi;

	    return {x: x, y: y, z: z};
	}
}


class ParticleManager {
	constructor() {
		this.particles = [];
		this.newParticles = [];

	}

	addParticle(p) {
		this.newParticles.push(p);
	}

	updateParticle(particle) {
		particle.update();
		return particle.isAlive;
	}

	updateAllParticles() {
		if (this.newParticles.length != 0) {
			this.particles = this.particles.concat(this.newParticles);
			this.newParticles = [];
		}

		this.particles = this.particles.filter(this.updateParticle);
	}
}


class Emitter {
	constructor(x, y, z, particleManager) {
		this.position = {x: x, y: y, z: z};
		this.particleManager = particleManager;

		this.newParticleParameters = {
			velocity: {
				x: {mean: 0, variance: 2},
				y: {mean: 30, variance: 5},
				z: {mean: 0, variance: 2},
			},
			secondsToLive: {mean: 4, variance: 0},
			level: 2,
		}
	}

	emitParticle() {
		var vx = this.random(this.newParticleParameters.velocity.x.mean, this.newParticleParameters.velocity.x.variance);
		var vy = this.random(this.newParticleParameters.velocity.y.mean, this.newParticleParameters.velocity.y.variance);
		var vz = this.random(this.newParticleParameters.velocity.z.mean, this.newParticleParameters.velocity.z.variance);
		var secondsToLive = this.random(this.newParticleParameters.secondsToLive.mean, this.newParticleParameters.secondsToLive.variance);

		this.particleManager.addParticle(new Particle(
			vector(this.position.x, this.position.y, this.position.z),
			vector(vx, vy, vz), secondsToLive, this.newParticleParameters.level));
	}

	random(mean, variance) {
  		return Math.random() * (variance + variance) + mean - variance;
	}
}


var scene, camera, renderer, geometry, mesh, material, uniforms, clock, controls;
var sphere, points, particle;

var particleManager, emitter;


function init(){

	// Init scene...
	scene = new THREE.Scene();

	// Init camera...
	camera = new THREE.PerspectiveCamera(90*window.innerHeight/window.innerWidth, window.innerWidth/window.innerHeight, 0.1, 10000);
	camera.position.set(-90, 90, 210);

	// Init renderer...
	renderer = new THREE.WebGLRenderer();
	renderer.setClearColor( 0x000000, 1.0 );
	renderer.setSize( window.innerWidth, window.innerHeight );
	document.body.appendChild( renderer.domElement );

	// Init camera orbiting controls...
	controls = new OrbitControls( camera, renderer.domElement );
	controls.autoRotate = true;

	// Init particle manager...
	particleManager = new ParticleManager();

	// Init particle emitter...
	emitter = new Emitter(0, 0, 0, particleManager);


	// Init keyboard controls...
	new InputManager();



	// Create ground...
	const groundGeometry = new THREE.PlaneGeometry(200, 200);
	const groundmaterial = new THREE.MeshBasicMaterial({color: 0x222222, side: THREE.DoubleSide});
	const ground = new THREE.Mesh(groundGeometry, groundmaterial);
	ground.rotateX(-Math.PI/2);
	scene.add(ground);


// var dotGeometry = new THREE.Geometry();
// dotGeometry.vertices.push(new THREE.Vector3( 1, 0, 1));
// var dotMaterial = new THREE.PointsMaterial( { size: 1, sizeAttenuation: false } );
// var dot = new THREE.Points( dotGeometry, dotMaterial );
// scene.add( dot );
// console.log(dot.geometry.attributes.position);
}
var stop = false;
function animate(){
	particleManager.updateAllParticles();

	renderer.render( scene, camera );
	if (!stop) requestAnimationFrame( animate );
}

class InputManager {
	constructor() {
		document.addEventListener("keypress", this.onKeyPressed);
	}

	onKeyPressed (event) {
		var key = event.key;
		if (key == ' ') {
			emitter.emitParticle();
		}
		else if (key == 'd') {
			stop = true;
		}
	};
}





init();
animate();
</script>
</body>
</html>